## Go Service

This app listens on port `8080` and exposes a single endpoint at `/` that resposds with the string `hello from go`. For every request it receives, it calls the Python service at `http://localhost:8082/` and appends the response from the Python service it's own response.

## Running the app

You'll need Go 1.13 and Make to be able to run the service. 

Run `make run` and then go to http://localhost:8080 to access the app.

## Instrumenting Go HTTP server and client with OpenTelemetry

### 1. Import packages required for instrumenting our Go app.

```diff
import (
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"time"

+	"go.opentelemetry.io/otel/api/core"
+	"go.opentelemetry.io/otel/api/global"
+	"go.opentelemetry.io/otel/api/trace"
+	"go.opentelemetry.io/otel/exporters/otlp"
+	"go.opentelemetry.io/otel/plugin/httptrace"
+	"go.opentelemetry.io/otel/plugin/othttp"
+	"go.opentelemetry.io/otel/sdk/resource/resourcekeys"
+	sdktrace "go.opentelemetry.io/otel/sdk/trace"
)
```

### 2. Configure OpenTelemetry tracer
```diff
	"go.opentelemetry.io/otel/plugin/othttp"
	"go.opentelemetry.io/otel/sdk/resource/resourcekeys"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

+func initTracer() error {
+	// configure trace exporter to export to locally running
+	// opentelemetry collector using the OTLP protocol.
+	exporter, err := otlp.NewExporter(
+		otlp.WithInsecure(),
+		otlp.WithAddress("localhost:55680"),
+	)
+	if err != nil {
+		return err
+	}
+
+	// configure default trace provider with the service name
+	tp, err := sdktrace.NewProvider(
+		sdktrace.WithConfig(sdktrace.Config{DefaultSampler: sdktrace.AlwaysSample()}),
+		sdktrace.WithSyncer(exporter),
+		sdktrace.WithResourceAttributes(core.Key(resourcekeys.ServiceKeyName).String("go-service")),
+	)
+	if err != nil {
+		return err
+	}
+
+	// set the configured trace provider as the global provider that other
+	// parts of the app can fetch and use.
+	global.SetTraceProvider(tp)
+	return nil
+}

func main() {
```

### 3. Add a tracer field to the server struct

We'll make the tracer available to all handlers as a field on the server struct. This is optionsl and handlers can fetch their own tracers from the `global` package directly if needed.

#### 3.a Add tracer field to server

```diff
type server struct {
+	tracer trace.Tracer
}
```

#### 3.b Initialize the tracer and add add it to the server instance
```diff
func main() {
+	initTracer()
+	tr := global.Tracer("go-demo")

-	s := &server{}
+	s := &server{
+		tracer: tr,
+	}

	var mux http.ServeMux
	mux.Handle("/", http.HandlerFunc(s.handler))
	check(http.ListenAndServe(":8080", &mux))
}
```

#### 4. Instrument the HTTP handler

We'll wrap our HTTP handler with the middleware/wrapper provided by the `othttp` package. The first argument is a handler func while the second is the operation name.

```diff
func main() {
	err := initTracer()
	check(err)
	tr := global.Tracer("go-demo")

	s := &server{
		tracer: tr,
	}

	var mux http.ServeMux
-	mux.Handle("/", http.HandlerFunc(s.handler))
+	mux.Handle("/", othttp.NewHandler(http.HandlerFunc(s.handler), "hello"))
	check(http.ListenAndServe(":8080", &mux))
}
```

At this point our app will generate one span for every request it receives. This will be auto-generated by the `othttp.NewHandler()` wrapper.

#### 5. Add a manual span to record an interesting operation. 

```diff
func (s *server) fetchFromPythonService(ctx context.Context) ([]byte, error) {
+	ctx, span := s.tracer.Start(ctx, "fetch-from-python")
+	defer span.End()

	client := &http.Client{
		Timeout: 5 * time.Second,
	}
	var body []byte

	req, err := http.NewRequest("GET", "http://localhost:8082/", nil)
	if err != nil {
		return body, err
	}

	res, err := client.Do(req)
	if err != nil {
		return body, err
	}
	body, err = ioutil.ReadAll(res.Body)
	err = res.Body.Close()

	return body, err
}

```

This will make our app generate a second span with operation name as `fetch-from-python`. The span will be a child of the previous auto-generated span.

#### 6. Instrument HTTP client request object to instrument outgoing requests.

Since we are making outgoing calls to an external service, we can wrap our HTTP request object using the `httptrace` package to auto-generate spans for operations related to the outgoing calls.

```diff
func (s *server) fetchFromPythonService(ctx context.Context) ([]byte, error) {
	ctx, span := s.tracer.Start(ctx, "fetch-from-python")
	defer span.End()

	client := &http.Client{
		Timeout: 5 * time.Second,
	}
	var body []byte

	req, err := http.NewRequest("GET", "http://localhost:8082/", nil)
	if err != nil {
		return body, err
	}

+	ctx, req = httptrace.W3C(ctx, req)
+	httptrace.Inject(ctx, req)

	res, err := client.Do(req)
	if err != nil {
		return body, err
	}
	body, err = ioutil.ReadAll(res.Body)
	err = res.Body.Close()

	return body, err
}
```

This will generate 4 more spans each representing a sub-operation of the outgoing HTTP request such as DNS resolution, establishing the connection and sending the request.

We can run the app again and this time it should emit spans to locally running OpenTelemetry collector.